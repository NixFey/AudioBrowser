@page "/"
@using AudioBrowser.Services
@using Humanizer.Bytes
@using Microsoft.Extensions.Options
@using Options = AudioBrowser.Options
@inject IOptionsMonitor<Options> Options
@inject NavigationManager NavManager
@inject ILogger<Program> Logger
@attribute [StreamRendering]
@implements IDisposable
@rendermode InteractiveServer


<PageTitle>Files</PageTitle>

<h1>Files</h1>

@if (_files is null)
{
    <p>Unable to get files</p>
}
else
{
    @if (_activeAudioPath is not null)
    {
        <div style="position: fixed;bottom: 0;left: 0;right: 0;width: 100%;border-top: 1px solid #666;background: white;padding: 0.5em;">
            <audio style="width: 100%" src="/file/@_activeAudioPath" controls autoplay></audio>
        </div>
    }
    
    @if (Path is not null && Path != "/" && Path != "")
    {
        <p>@(Path)</p>
        <p><a href="javascript:false;" @onclick="@(TraverseUp)">Go up</a></p>
    }
    
    <ul style="margin-bottom: 10em;" class="audioList">
        @foreach (var file in _files)
        {
            <li>
                <a
                    href="javascript:false;"
                    @onclick="@(() => ChooseFile(file))"
                    data-active="@(!string.IsNullOrEmpty(_activeAudioPath) && file.FullName.EndsWith(_activeAudioPath) ? "true" : null)">
                    @(!file.Attributes.HasFlag(FileAttributes.Directory) ? XAttrsService.GetBool((FileInfo)file, "heard") ?? false ? "✅" : "➡️" : "📁")
                    @file.Name
                    @(file is FileInfo fi ? $" - {Math.Round(ByteSize.FromBytes(fi.Length).Kilobytes)} KB" : "")
                </a>
            </li>
        }
    </ul>
}

<style>
    .audioList a[data-active] {
        background: #ee9;
        padding-block: 3px;
    }
    
    .audioList a {
        scroll-margin-block: 11em;
    }
</style>

<script>
    if (window.__initialized !== true) {
        window.__initialized = true;
        const getFileEls = () => Array.from(document.querySelectorAll(".audioList a"));
        document.addEventListener("keydown", (e) => {
            if (e.key === "ArrowDown" || e.key === "ArrowUp") {
                e.preventDefault();
                const files = getFileEls();
                const activeIndex = files.findIndex(f => f.hasAttribute("data-active"));
                
                if (activeIndex === -1) return;
                
                const changeAudio = (el) => {
                    el.scrollIntoView({
                        block: "nearest",
                        behavior: "smooth"
                    });
                    el.click();
                };
                
                if (e.key === "ArrowDown") {
                    const newIndex = activeIndex + 1;
                    if (newIndex >= files.length) return;
                    
                    changeAudio(files[newIndex]);
                } else if (e.key === "ArrowUp") {
                    const newIndex = activeIndex - 1;
                    if (newIndex <= 0) return;

                    changeAudio(files[newIndex]);
                }
            } else if (e.key === " ") {
                e.preventDefault();
                const audio = document.querySelector("audio");
                
                if (audio === null || audio.currentSrc === "") return;
                
                if (audio.paused) {
                    audio.play();
                } else {
                    audio.pause();
                }
            }
        });
    }
</script>

@code {
    [Parameter]
    [SupplyParameterFromQuery]
    public string? Path { get; set; }

    private DirectoryInfo? _directory;
    private FileSystemInfo[]? _files;

    private string? _activeAudioPath;

    private void GetFiles()
    {
        var rootPath = Options.CurrentValue.FilesDirectory.FullName;
        _directory = new DirectoryInfo(System.IO.Path.Join(Options.CurrentValue.FilesDirectory.FullName, Path));
        if (!_directory.FullName.StartsWith(rootPath)) throw new ApplicationException("Bad.");
        _files = _directory.EnumerateFileSystemInfos().OrderByDescending(f => f.Attributes.HasFlag(FileAttributes.Directory)).ThenBy(f => f.Name).ToArray();
    }
    
    protected override Task OnInitializedAsync()
    {
        WatcherService.FilesChanged += WatcherServiceOnFilesChanged;
        
        GetFiles();

        return Task.CompletedTask;
    }

    public void Dispose()
    {
        WatcherService.FilesChanged -= WatcherServiceOnFilesChanged;
    }

    private async void WatcherServiceOnFilesChanged(object? sender, EventArgs e)
    {
        Logger.LogDebug("Got a change, rerendering");
        await InvokeAsync(async () =>
        {
            await OnInitializedAsync();
            StateHasChanged();
        });
    }

    protected override Task OnParametersSetAsync()
    {
        GetFiles();
        return Task.CompletedTask;
    }

    private void ChooseFile(FileSystemInfo fileSystemInfo)
    {
        var relativePath = System.IO.Path.GetRelativePath(Options.CurrentValue.FilesDirectory.FullName, fileSystemInfo.FullName);
        if (fileSystemInfo.Attributes.HasFlag(FileAttributes.Directory))
        {
            NavManager.NavigateTo(NavManager.GetUriWithQueryParameter("path", relativePath));
        }
        else
        {
            var currentStatus = XAttrsService.GetBool((FileInfo)fileSystemInfo, "heard");
            if (currentStatus != true)
                XAttrsService.SetBool((FileInfo)fileSystemInfo, "heard", !(currentStatus ?? false));
            _activeAudioPath = relativePath;
            StateHasChanged();
        }
    }

    private void TraverseUp()
    {
        var relativePath = System.IO.Path.GetRelativePath(Options.CurrentValue.FilesDirectory.FullName, System.IO.Path.Join(_directory!.FullName, ".."));
        NavManager.NavigateTo(NavManager.GetUriWithQueryParameter("path", relativePath));
    }
    
}